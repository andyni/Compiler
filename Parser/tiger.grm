structure A = Absyn

%%
%term
    EOF 
  | ID of string
  | INT of int | STRING of string 
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK 
  | LBRACE | RBRACE | DOT 
  | PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF 
  | BREAK | NIL
  | FUNCTION | VAR | TYPE
  | UMINUS 

%nonterm  exp | program | decs | dec | sequence | funlist | intexp | ifstmt
 | compexp | boolop | comptype | tydec | ty | record | recordlist |
 tyfields | vardec | fundec | lvalue | evalsequence

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE 
	DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

(* precedence *)
%nonassoc ID THEN
%left OR
%left AND
%nonassoc EQ NEQ GE LE GT LT
%left PLUS MINUS
%left TIMES DIVIDE
%left UMINUS 
%right LBRACK COMMA ELSE


%%

program	: exp (exp)
	
exp: lvalue (lvalue)
   | NIL (A.NilExp)
   | LPAREN evalsequence RPAREN (A.SeqExp(evalsequence))
   | intexp (intexp)
   | STRING (A.StringExp(STRING,defaultPos))
   | ID LPAREN funlist RPAREN (A.CallExp({func=ID, args=funlist, pos=ID1left}))
   | boolop (boolop)
   | record (record)
   | ID LBRACK exp RBRACK OF exp (A.ArrayExp({typ=ID, size=exp1, init=exp2,
   pos=ID1left}))
   | lvalue ASSIGN exp (A.AssignExp({var=lvalue,exp=exp,pos=lvalue1left}))
   | WHILE compexp DO exp (A.WhileExp({test=compexp,body=exp,pos=WHILE1left}))
   | FOR ID ASSIGN exp TO exp DO exp (A.ForExp({var=ID,escape=true,lo=exp1,hi=exp2,body=exp3,pos=FOR1left}))
   | BREAK (A.BreakExp(defaultPos))
   | LET decs IN sequence END (A.LetExp({decs=decs,body=sequence,pos=LET1left}))
   | LPAREN exp RPAREN (exp) 
   | IF compexp THEN exp (A.IfExp({test=compexp,then'=exp,else'=NONE,pos=IF1left}))
   | IF compexp THEN exp ELSE exp (A.IfExp({test=compexp,then'=exp1,else'=SOME(exp2),pos=IF1left}))

decs : dec decs (dec::decs)
     | (A.NilExp) 

dec : tydec (tydec)
     | vardec (vardec)
     | fundec (fundec)

sequence : exp (exp)
         | sequence SEMICOLON exp (exp)
         | (A.NilExp)

evalsequence : exp SEMICOLON exp ([(exp1,exp1left),(exp2,exp2left)])
             | exp SEMICOLON evalsequence  ((exp,exp1left)::evalsequence)

funlist : exp ([exp]) 
         | exp COMMA funlist (exp::funlist)
         | ([])

intexp : intexp PLUS intexp (A.OpExp({left=intexp1,oper=Absyn.PlusOp,right=intexp2,pos=intexp1left}))
	 | intexp MINUS intexp (A.OpExp({left=intexp1,oper=Absyn.MinusOp,right=intexp2,pos=intexp1left}))
	 | intexp TIMES intexp (A.OpExp({left=intexp1,oper=Absyn.TimesOp,right=intexp2,pos=intexp1left}))
	 | intexp DIVIDE intexp (A.OpExp({left=intexp1,oper=Absyn.DivideOp,right=intexp2,pos=intexp1left}))       
         | MINUS intexp (A.OpExp({left=A.IntExp(0),oper=Absyn.MinusOp,right=intexp,pos=intexpleft}))
	 | INT (A.IntExp(INT))

compexp : comptype EQ comptype (A.OpExp({left=comptype1,oper=A.EqOp,right=comptype2,pos=comptype1left}))
	 | comptype NEQ comptype (A.OpExp({left=comptype1,oper=A.NeqOp,right=comptype2,pos=comptype1left}))
	 | comptype LE comptype (A.OpExp({left=comptype1,oper=A.LeOp,right=comptype2,pos=comptype1left}))
	 | comptype LT comptype (A.OpExp({left=comptype1,oper=A.LtOp,right=comptype2,pos=comptype1left}))
	 | comptype GE comptype (A.OpExp({left=comptype1,oper=A.GeOp,right=comptype2,pos=comptype1left}))
	 | comptype GT comptype (A.OpExp({left=comptype1,oper=A.GtOp,right=comptype2,pos=comptype1left}))
         | ID EQ ID  (A.OpExp({left=A.VarExp(A.SimpleVar(ID1,ID1left)),oper=A.EqOp,right=A.VarExp(A.SimpleVar(ID2,ID2right)),pos=ID1left}))
	 | ID NEQ ID (A.OpExp({left=A.VarExp(A.SimpleVar(ID1,ID1left)),oper=A.NeqOp,right=A.VarExp(A.SimpleVar(ID2,ID2right)),pos=ID1left}))
         | intexp (intexp)

boolop : compexp AND compexp (A.IfExp({test=compexp1, then'=compexp2, else'=A.IntExp(0),pos=compexp1left}))
	 | compexp OR compexp (A.IfExp({test=compexp1, then'=A.IntExp(1),
	 else'=compexp2, pos=compexp1left}))

comptype : STRING (A.StringExp(STRING,defaultPos))
	 | intexp (intexp)

tydec : TYPE ID EQ ty (A.TypeDec({name=ID,ty=ty,pos=defaultPos})) 

ty : ID (A.NameTy(ID,defaultPos))
   | LBRACE tyfields RBRACE (A.RecordTy(tyfields)) 
   | ARRAY OF ID (A.ArrayTy(ID,defaultPos))

record : ID LBRACE recordlist RBRACE (A.RecordExp({fields=recordlist,
typ=ID, pos=ID1left}))

recordlist : ID EQ exp ((ID,exp,ID1left))
           | ID EQ exp COMMA recordlist ((ID,exp,ID1left)::recordList2)
           | ((nil,nil,nil)

tyfields : ID COLON ID ({name=ID1,escape=true,typ=ID2,pos=ID1left}) 
         | ID COLON ID COMMA tyfields ({name=ID1,escape=true,typ=ID2,pos=ID1left} :: tyfields)
         | (A.NilExp)

vardec : VAR ID ASSIGN exp (A.VarDec({name=ID, escape=true, typ=NONE,
init=exp, pos=ID1left}))
       | VAR ID COLON ID ASSIGN exp (A.VarDec({name=ID1, escape=true, typ=SOME(ID2,ID2left),
init=exp, pos=ID1left}))

fundec : FUNCTION ID LPAREN tyfields RPAREN EQ exp ({name=ID,
params=tyfields, result=NONE, body=exp, pos=ID1left})
       | FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ exp ({name=ID1,
params=tyfields, result=SOME(ID2, ID2left), body=exp, pos=ID1left})

lvalue : ID (A.SimpleVar(ID,defaultPos))
       | lvalue DOT ID (A.FieldVar(lvalue,ID,lvalue1left))
       | lvalue LBRACK exp RBRACK (A.SubscriptVar(lvalue,exp,lvalue1left))  
